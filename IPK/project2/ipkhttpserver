#!/usr/bin/env python3
__author__ = 'xcoufa09'

import logging
import os
import socketserver
from argparse import ArgumentParser
from datetime import datetime
from time import sleep
from mimetypes import guess_type

CHUNK_SIZE = '4096'
DEFAULT_PORT = '8080'
DELAY = '0'
DATA_FOLDER = 'www'
RESPONSE = 'HTTP/1.1 {0} {1}\r\n{2}'
LOG_NAME = 'ipkHttpServer-{0}'.format(datetime.today().
                                      strftime('%Y-%m-%d:%H:%M:%S'))

in_log = logging.getLogger('IN')
in_log.setLevel(level=logging.INFO)
in_log.addHandler(logging.FileHandler(LOG_NAME + '.in.log'))

out_log = logging.getLogger('OUT')
out_log.setLevel(level=logging.INFO)
out_log.addHandler(logging.FileHandler(LOG_NAME + '.out.log'))

class FileSend(socketserver.BaseRequestHandler):
    """
    RequestHandler class for the server

    Overrides the handle() method to implement the communication to the client
    """
    def __init__(self, request, client_address, server):
        self.logger = dict()
        self.logger['IN'] = logging.getLogger('IN')
        self.logger['OUT'] = logging.getLogger('OUT')
        socketserver.StreamRequestHandler.__init__(self,
                                                   request,
                                                   client_address,
                                                   server)

    def handle(self):
        """
        TCP socket handler which sends desired file to the client
        """
        # read data from the socket
        self.data = self.request.recv(CHUNK_SIZE).decode('utf-8')
        self.logger['IN'].info(self.data)
        request = self.data.split()

        # check for valid HTTP protocol
        if request[0] != 'GET' or request[2] != 'HTTP/1.1':
            self.message = bytes(RESPONSE.format('400','Bad Request',''), encoding='utf-8')
            self.respond()
            return

        path = os.path.join(os.getcwd(), DATA_FOLDER) + request[1]

        if not os.path.isfile(path):
            self.message = bytes(RESPONSE.format('404','Not Found', ''), encoding='utf-8')
            self.respond()
            return

        # file was found, respond it's content
        self.message = bytes(RESPONSE.format('200', 'OK',
                            'Content-Type: ' + guess_type(path)[0] + '\r\n'), encoding='utf-8')
        if os.path.getsize(path) > CHUNK_SIZE:
            self.message += b'Transfer-Encoding: chunked\r\n'
            with open(path, 'rb') as f:
                while True:
                    content = f.read(CHUNK_SIZE)
                    if not content:
                        break
                    chunk_hex_size = hex(len(content)).split('x')[-1]
                    chunk_hex_size = bytes(chunk_hex_size, encoding='utf-8')
                    self.message += b'\r\n' + chunk_hex_size + b'\r\n' + content
                    self.respond()
                    if DELAY != 0:
                        sleep(DELAY / 1000)
                    self.message = bytes()
        else:
            with open(path, 'rb') as f:
                content = f.read()
            self.message += b'\r\n' + content
            self.respond()

    def respond(self):
        self.logger['OUT'].info(self.message)
        self.request.sendall(self.message)


def parse_args():
    """Argument parser"""
    parser = ArgumentParser(description="HTTP TCP/IP server",
                            epilog='Tomas Coufal <xcoufa09@stud.fit.vutbr.cz>')
    parser.add_argument('-p', action='store', default=DEFAULT_PORT, metavar='PORT',
                        help='specify port number')
    parser.add_argument('-c', action='store', default=CHUNK_SIZE, metavar='CHUNK_SIZE',
                        help='maximal size of chunk')
    parser.add_argument('-t', action='store', default=DELAY, metavar='TIME',
                        help='minimal delay between sent chunks')
    return vars(parser.parse_args())

if __name__ == "__main__":
    args = parse_args()
    CHUNK_SIZE = int(args['c'])
    DELAY = float(args['t'])
    host, port = "localhost", int(args['p'])
    server = socketserver.TCPServer((host, port), FileSend)
    server.serve_forever()
