#!/usr/bin/env python3
__author__ = 'xcoufa09'

import logging
import os
import socketserver
from argparse import ArgumentParser
from datetime import datetime
from time import sleep
from mimetypes import guess_type

CHUNK_SIZE = '4096'
CHUNK_SIZE_REQUEST = 4096
DEFAULT_PORT = '8080'
DELAY = '0'
DATA_FOLDER = 'www'
RESPONSE = 'HTTP/1.1 {0} {1}\r\n{2}'
LOG_NAME = 'ipkHttpServer-{0}'.format(datetime.today().
                                      strftime('%Y-%m-%d:%H:%M:%S'))

in_log = logging.getLogger('IN')
in_log.setLevel(level=logging.INFO)
in_log.addHandler(logging.FileHandler(LOG_NAME + '.in.log'))

out_log = logging.getLogger('OUT')
out_log.setLevel(level=logging.INFO)
out_log.addHandler(logging.FileHandler(LOG_NAME + '.out.log'))


class FileSend(socketserver.BaseRequestHandler):
    """
    RequestHandler class for the server

    Overrides the handle() method to implement the communication to the client
    """
    def __init__(self, request, client_address, server):
        self.header = str()
        self.message = bytes()
        self.logger = dict()
        self.logger['IN'] = logging.getLogger('IN')
        self.logger['OUT'] = logging.getLogger('OUT')
        socketserver.StreamRequestHandler.__init__(self,
                                                   request,
                                                   client_address,
                                                   server)

    def handle(self):
        """
        TCP socket handler which sends desired file to the client
        """
        # read data from the socket
        self.data = self.request.recv(CHUNK_SIZE_REQUEST).decode('utf-8')
        self.logger['IN'].info(self.data)
        request = self.data.split()

        # check for valid HTTP protocol
        if request[0] != 'GET' or request[2] != 'HTTP/1.1':
            self.header = RESPONSE.format('400', 'Bad Request', '')
            self.respond()
            return

        path = os.path.join(os.getcwd(), DATA_FOLDER) + request[1]

        if not os.path.isfile(path):
            self.header = RESPONSE.format('404', 'Not Found', '')
            self.respond()
            return

        # file was found, respond it's content
        mimetype = guess_type(path)[0]
        self.header = RESPONSE.format('200', 'OK',
                                      'Content-Type: {0}\r\n'.format(mimetype))
        if os.path.getsize(path) > CHUNK_SIZE:
            self.header += 'Transfer-Encoding: chunked\r\n'
            header = True
            # send by chunks
            with open(path, 'rb') as f:
                while True:
                    content = f.read(CHUNK_SIZE)
                    if not content:
                        break
                    ch_hex = hex(len(content)).split('x')[-1].encode('utf-8')
                    self.message = ch_hex + b'\r\n' + content
                    self.respond(header=header)
                    if header:
                        header = False
                    sleep(DELAY)
            # send final chunk
            self.message = b'0\r\n\r\n'
            self.respond(header=False)
        else:
            with open(path, 'rb') as f:
                content = f.read()
            self.message = content
            self.respond()

    def respond(self, header=True):
        response = bytes()
        if header:
            response = self.header.encode('utf-8')
        response += b'\r\n' + self.message
        self.logger['OUT'].info(response)
        self.request.sendall(response)


def parse_args():
    """Argument parser"""
    parser = ArgumentParser(description="HTTP TCP/IP server",
                            epilog='Tomas Coufal <xcoufa09@stud.fit.vutbr.cz>')
    parser.add_argument('-p', action='store', default=DEFAULT_PORT,
                        metavar='PORT', help='specify port number')
    parser.add_argument('-c', action='store', default=CHUNK_SIZE,
                        metavar='CHUNK_SIZE', help='maximal size of chunk')
    parser.add_argument('-t', action='store', default=DELAY, metavar='TIME',
                        help='minimal delay between sent chunks')
    return vars(parser.parse_args())

if __name__ == "__main__":
    args = parse_args()
    CHUNK_SIZE = int(args['c'])
    DELAY = float(args['t']) / 1000
    host, port = "localhost", int(args['p'])
    server = socketserver.TCPServer((host, port), FileSend)
    server.serve_forever()
